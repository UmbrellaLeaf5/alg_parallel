# Lesson 8

# OpenMP

## Принципы OpenMP

Распараллеливание выполняется с помощью вставки в текст специальных директив (прагм) и вызова вспомогательных процедур.

В программе выделяются последовательные и параллельные области.

Программа всегда начинается с последовательной области – работает одна нить исполнения – главная или мастер-нить.

При входе в параллельную область порождается еще некоторое количество нитей исполнения, между которыми распределяется выполнение кода параллельной области.

При выходе из параллельной области все нити, кроме главной нити (нити-мастера) завершаются.

## Прагмы (директивы) и процедуры

Общий вид директивы
```cpp
#pragma omp pragma_name [opt[[,] opt]...]
```

Область действия: оператор или блок операторов в фигурных скобках, непосредственно следующий за прагмой

Категории прагм:
* определение параллельной области
* распределение работы в параллельной области
* синхронизация работы нитей исполнения

Для использования процедур в программу необходимо добавить include:
```cpp
#include <omp.h> 
```

! Имена всех процедур в OpenMP начинаются с префикса `omp_`

Процедуры используются:
* для получения информации о режимах работы программы
* для установления таких режимов работы
* для получения информации о параметрах вычислительной среды и нитей исполнения

## Компиляция и запуск на головном узле
```shell
g++ -std=c++11 main.cpp -fopenmp
qsub start.sh
```

## Определение параллельной области

Для определения параллельной области применяется директива `parallel`.

Общий вид директивы:
```cpp
#pragma omp parallel [opt[[,] opt]...]
```

### Пример: 
```cpp
#include <iostream>
// #include <omp.h>

int main() {
  // sequential part:

  std::cout << "Sequential Hello World!" << std::endl;

  // parallel part:
#pragma omp parallel
  { std::cout << "Parallel Hello World!" << std::endl; }

  return 0;
}
```

## Изменение количества нитей

Для изменения количества нитей, работающих в параллельной области, можно использовать либо вспомогательную процедуру, либо опцию директивы `parallel`.

Вспомогательная процедура:
```cpp
void omp_set_num_threads(int num);
```
Опция прагмы parallel:
```cpp
#pragma omp parallel num_threads(5)
```

### Пример:
```cpp
#include <iostream>

#include <omp.h>

int main() {
  // sequential part:

  std::cout << "Sequential Hello World!" << std::endl;

  omp_set_num_threads(3);  // установка 3 нитей

  // parallel part:
#pragma omp parallel num_threads(5)  // установка 5 нитей
  { std::cout << "Parallel Hello World!" << std::endl; }

  return 0;
}
```

## Виды переменных в нитях

Все переменные в параллельных блоках делятся на
2 вида:
* `shared` – общие для всех нитей параллельной части
* `private` – свои для каждой нити параллельной части

По умолчанию:
* `private` – все переменные, описанные внутри параллельного блока без слова `static`
* `shared` – все переменные, описанные вне параллельного блока (кроме счетчиков параллельных циклов) или внутри его со словом `static`, динамически выделенная память.

! Переменные, описанные без слова `static` внутри параллельного блока, сделать общими для этого блока нельзя.

Внешние переменные (кроме динамически выделенной памяти), могут быть приватизированы с использованием опций директивы `parallel`.

Рекомендуется для ясности все внешние переменные, используемые в параллельных блоках, относить к видам `shared` или `private` явно с помощью соответствующих опций.

Опция shared для прагмы parallel:
```
shared (имя[, имя[, ...]])
```

Опция private для прагмы parallel:
```
private (имя[, имя[, ...]])
```

Переменные, приватизированные с помощью опции private, имеют неопределенные начальные значения.

### Пример 1:
```cpp
// #include <iostream>
#include <stdio.h>

// #include <omp.h>

int x_0 = 2;

int main() {
  // sequential part:

  int x_1 = 2;

  // parallel part:
#pragma omp parallel shared(x_0, x_1)
  {
    int x_2 = 0;
    static int x_3 = 0;
    x_0++;
    x_1++;
    x_2++;
    x_3++;

    // std::cout << "x_0 = " << x_0 << " ; x_1 = " << x_1 << " ; x_2 = " << x_2
    //           << " ; x_3 = " << x_3 << std::endl;
    printf("x_0 = %d; x_1 = %d; x_2 = %d; x_3 = %d;\n", x_0, x_1, x_2, x_3);
  }

  // sequential part:

  // std::cout << "x_0 = " << x_0 << " ; x_1 = " << x_1 << std::endl;
  printf("x_0 = %d; x_1 = %d;\n", x_0, x_1);

  return 0;
}
```

### Пример 2:
```cpp
// #include <iostream>
#include <stdio.h>

// #include <omp.h>

int x_0 = 2;

int main() {
  // sequential part:

  int x_1 = 2;

  // parallel part:
#pragma omp parallel shared(x_0) private(x_1)
  {
    int x_2 = 0;
    static int x_3 = 0;
    x_0++;
    x_1++;
    x_2++;
    x_3++;

    // std::cout << "x_0 = " << x_0 << " ; x_1 = " << x_1 << " ; x_2 = " << x_2
    //           << " ; x_3 = " << x_3 << std::endl;
    printf("x_0 = %d; x_1 = %d; x_2 = %d; x_3 = %d;\n", x_0, x_1, x_2, x_3);
  }

  // sequential part:

  // std::cout << "x_0 = " << x_0 << " ; x_1 = " << x_1 << std::endl;
  printf("x_0 = %d; x_1 = %d;\n", x_0, x_1);

  return 0;
}
```

Для приватизации переменных в параллельном блоке с сохранением последнего значения, присвоенного перед блоком, используется опция `firstprivate` прагмы `parallel`
```
firstprivate (имя[, имя[, ...]])
```

### Пример 3:
```cpp
int main() {
  // sequential part:
  { int a = 2, b = 1, c[10], d[2] = {1, 1}; }
  // parallel part:
#pragma omp parallel shared (b, c, a) firstprivate(d)
  {}
}
```

## Информационные процедуры

Определение количества исполнителей:
```cpp
int omp_get_num_procs(void);
```

Определение количества работающих нитей:
```cpp
int omp_get_num_threads(void);
```

Определение номера текущей нити:
```cpp
int omp_get_thread_num(void);
```

# Task `Hello, OMP!`

Напишите программу с 2-мя последовательными и одной параллельной частью.

В 1-й последовательной части определите и напечатайте количество ядер на узле, где выполняется программа.

В параллельной части запустите 6 нитей. Каждая из них приветствует OMP, сообщает свой номер и общее количество работающих нитей.

Во 2-й последовательной части напечатайте номер работающей нити и количество нитей.
